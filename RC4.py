import wep_security as ws
import scapy
import binascii
from scapy import utils
from scapy.all import *


def get_iv(arg):
    opl = []
    for pkt in scapy.utils.RawPcapReader('iv-03.cap'):
        if pkt[1][1] > 0:
           opl += [(binascii.hexlify(str(pkt[1][1])))]
    a = str(opl[arg -1])

    b = []
    for i in range(1,len(a),2):
        b.append(int(a[i-1:i+1]))
    return b

def plaintext_to_hex(message_list):
    """
    :param message_list: is a list of values in asc2
    :return: a string where each hex value is separated by a space
    """
    hex_str = ''
    for elem in message_list:
        if len(hex_str) > 0:
            hex_str += ' '
        hex_value = str(chr(elem)).encode("hex")
        hex_str += hex_value
    return hex_str


def hex_to_plaintext(message_string):
    """
    :param message_string: a string of hex values that are separated by a space
    :return: a list of values in asc2
    """
    opl = []
 
    message_list = message_string.split(' ')
    for elem in message_list:
        char = int(elem[0:2], 16)
        opl.append(char)
    return opl


def make_key(password, message,iv = None):
    """
    :param password: the password of the router (string)
    :param message: the message that needs to be sent or the message that has been received (encrypted) (string)
    :return: the key value generated by the RC4 algorithm (is a list of positive integers)
    """
    asc_password = ws.text_to_asc(password)
    if iv is None:
        S,iv = ws.KSA(asc_password)
    else:
        S,iv = ws.KSA(asc_password,iv)
    key = ws.PRGA(S, message)
    return key,iv


def encryption(password, message):
    """
    This definition encrypts the given message with the given password of the router using
    the RC4 algorithm used by WEP protocol
    :param password: the password of the router (string)
    :param message: the message that needs to be sent and encrypted (string)
    :return: the hex decimal string of the encrypted message (string where each hex value is
             separated by a space)
    """
    key,iv = make_key(password, message)
    asc_message = ws.text_to_asc(message)
    encrypted_message = xor(key,asc_message)
    hex_string = plaintext_to_hex(encrypted_message)
    hex_iv = plaintext_to_hex(iv)
    packet = hex_iv + ' ' + hex_string
    return packet


def decryption(password, packet, iv):
    """
    This definition decrypts the hex values given by the package captured by our WEP sniffer
    :param password: the password of the router (string)
    :param encrypted_message: a string with hex values separated by a space
    :return: the original message send by the client (string)
    """
    encrypted_message = packet
    plain_text = hex_to_plaintext(encrypted_message)
    #print([chr(elem) for elem in plain_text])
    # iv = get_iv(arg)
    plain_iv = hex_to_plaintext(iv)
    key,_ = make_key(password, plain_text,plain_iv)
    decrypted_message_asc = xor(key,plain_text)
    decrypted_message = [chr(elem) for elem in decrypted_message_asc]
    opl = ""
    for elem in decrypted_message:
        opl += elem
    return opl

def xor(first_list,second_list):
    """
    :param first_list: list with asc2 values
    :param second_list: list with asc2 values
    :return: XOR list of the 2 lists
    """
    xor_message = []
    if len(first_list) != len(second_list):
        return False
    else:
        for i in range(len(first_list)):
            xor_message.append(first_list[i] ^ second_list[i])
        return xor_message